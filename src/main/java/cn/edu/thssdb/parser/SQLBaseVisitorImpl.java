package cn.edu.thssdb.parser;

/**
 *     This is an implementation of SQLBaseVisitor.
 *     It visits a parsing tree generated by SQLParse,
 *     does sanity check in syntax level,
 *     and calls a handler for execution.
 *     *Assume the input has a correct grammar.
 *     ***
 *         Note: all the handlers this class calls is from interface:
 *         cn.edu.thssdb.query.QueryManager
 *     ***
 */

import cn.edu.thssdb.exception.ManagerNotReadyException;
import cn.edu.thssdb.predicate.Operand;
import cn.edu.thssdb.predicate.base.Predicate;
import cn.edu.thssdb.predicate.compare.*;
import cn.edu.thssdb.predicate.logical.AndPredicate;
import cn.edu.thssdb.predicate.logical.OrPredicate;
import cn.edu.thssdb.query.QueryManagerInterface;
import cn.edu.thssdb.schema.Entry;
import cn.edu.thssdb.schema.VirtualTable;
import cn.edu.thssdb.type.ColumnType;
import cn.edu.thssdb.utils.LogBuffer;
import com.sun.istack.internal.NotNull;

import java.util.ArrayList;

public class SQLBaseVisitorImpl extends SQLBaseVisitor<Object> {

    private QueryManagerInterface queryManager = null;
    private LogBuffer logBuffer = null;
    public boolean hasSyntaxError = false;


    // Bind to a query manager. All sql command is executed by the manager.
    public void bindQueryManager(@NotNull QueryManagerInterface manager, @NotNull LogBuffer buffer) throws ManagerNotReadyException {
        if (manager.ready()) {
            this.queryManager = manager;
            this.logBuffer = buffer;
        }
        else {
            throw new ManagerNotReadyException();
        }
    }

    // Assume the input has a correct grammar.
    @Override
    public Object visitParse(SQLParser.ParseContext ctx) {
        hasSyntaxError = false;
        // if there is error when parsing, stop
        if (logBuffer.hasSyntaxError) {
            return null;
        }
        queryManager.startTransaction();
        super.visitParse(ctx);
        // submit the transaction if no syntax error is found
        if (hasSyntaxError) {
            queryManager.rollback();
        }
        else {
            queryManager.commit();
        }
        return null;
    }

    @Override
    public Object visitSql_stmt_list(SQLParser.Sql_stmt_listContext ctx) {
        return super.visitSql_stmt_list(ctx);
    }

    //
    @Override
    public Object visitSql_stmt(SQLParser.Sql_stmtContext ctx) {
        if (!hasSyntaxError) {
            super.visitSql_stmt(ctx);
        }
        return null;
    }

    @Override
    public Object visitCreate_table_stmt(SQLParser.Create_table_stmtContext ctx) {
        String table_name = ctx.table_name().getText();
        ArrayList<Column> columns = new ArrayList<>();
        // construct column definition
        for (SQLParser.Column_defContext context : ctx.column_def()) {
            Object object = visitColumn_def(context);
            if (object == null) {
                return null;
            }
            columns.add((Column) object);
        }
        // when primary key is specified at the end of command
        if (ctx.table_constraint() != null) {
            if (ctx.table_constraint().column_name().size() != 1) {
                logBuffer.write("NotImplementError: Primary key for more than one attribute not supported (for now).");
                hasSyntaxError = true;
                return null;
            }
            else {
                String primary = ctx.table_constraint().column_name(0).getText();
                boolean primary_key_set = false;
                for (Column column : columns) {
                    if (column.getName().equals(primary)) {
                        column.setPrimary(true);
                        primary_key_set = true;
                        break;
                    }
                }
                if (!primary_key_set) {
                    logBuffer.write("SyntaxError: specified primary key not found.");
                    hasSyntaxError = true;
                    return null;
                }
            }
        }
        else {
            logBuffer.write("SyntaxError: you need to specify a primary key.");
            hasSyntaxError = true;
            return null;
        }
        queryManager.createTable(table_name, columns);
        return null;
    }

    @Override
    public Object visitDelete_stmt(SQLParser.Delete_stmtContext ctx) {
        Predicate predicate = null;
        if (ctx.multiple_condition() != null) {
            predicate = (Predicate)visitMultiple_condition(ctx.multiple_condition());
        }
        queryManager.deleteRows(ctx.table_name().getText(), predicate);
        return null;
    }

    @Override
    public Object visitDrop_table_stmt(SQLParser.Drop_table_stmtContext ctx) {
        if (ctx.K_IF() != null) {
            logBuffer.write("NotImplementError: if exists not implemented.");
            hasSyntaxError = true;
            return null;
        }
        queryManager.dropTable(ctx.table_name().getText());
        return null;
    }

    @Override
    public Object visitQuit_stmt(SQLParser.Quit_stmtContext ctx) {
        queryManager.quit();
        return null;
    }

    @Override
    public Object visitShow_meta_stmt(SQLParser.Show_meta_stmtContext ctx) {
        queryManager.showTable(ctx.table_name().getText());
        return null;
    }

    @Override
    public Object visitInsert_stmt(SQLParser.Insert_stmtContext ctx) {
        ArrayList<Column> columns = new ArrayList<Column>();
        ArrayList<Row> entries = new ArrayList<Row>();
        int row_length = 0;
        // if column name is provided
        if (ctx.column_name() != null && ctx.column_name().size() != 0) {
            for (SQLParser.Column_nameContext column : ctx.column_name()) {
                columns.add(new Column(column.getText(), null, false, false, 0));
            }
            row_length = columns.size();
        }
        else {
            columns = null;
        }
        // one element is a row
        for (SQLParser.Value_entryContext entry : ctx.value_entry()) {
            entries.add((Row) visitValue_entry(entry));
        }
        // if column names not specified, take the length of the first entry as row length
        if (row_length == 0) {
            row_length = entries.get(0).size();
        }
        for (Row entry : entries) {
            if (entry.size() != row_length) {
                logBuffer.write("SyntaxError: rows should have the same size as schema size.");
                hasSyntaxError = true;
            }
        }
        queryManager.insertRow(ctx.table_name().getText(), columns, entries);
        return null;
    }

    @Override
    public Object visitValue_entry(SQLParser.Value_entryContext ctx) {
        ArrayList<Entry> entries = new ArrayList<Entry>();
        // add each literal
        for (SQLParser.Literal_valueContext entry : ctx.literal_value()) {
            entries.add(((Operand)visitLiteral_value(entry)).getValue());
        }
        return new Row(entries);
    }

    @Override
    public Object visitSelect_stmt(SQLParser.Select_stmtContext ctx) {
        if (ctx.K_DISTINCT() != null) {
            logBuffer.write("NotImplementError: 'distinct' not implemented.");
            hasSyntaxError = true;
            return null;
        }
        if (ctx.K_ALL() != null) {
            logBuffer.write("NotImplementError: 'all' not implemented.");
            hasSyntaxError = true;
            return null;
        }
        if (ctx.table_query().size() > 1) {
            logBuffer.write("NotImplementError: query from more than one table not implemented.");
            hasSyntaxError = true;
            return null;
        }

        ArrayList<Column> columns = new ArrayList<>();
        for (SQLParser.Result_columnContext columnContext : ctx.result_column()) {
            Column column = (Column) visitResult_column(columnContext);
            if (column == null) {
                return null;
            }
            columns.add(column);
        }
        Predicate condition = null;
        if (ctx.multiple_condition() != null) {
            condition = (Predicate)visitMultiple_condition(ctx.multiple_condition());
        }
        VirtualTable vt = (VirtualTable)visitTable_query(ctx.table_query(0));

        queryManager.select(columns, vt, condition);
        return null;
    }

    @Override
    public Object visitUpdate_stmt(SQLParser.Update_stmtContext ctx) {
        String table_name = ctx.table_name().getText();
        String column_name = ctx.column_name().getText();
        Operand operand = (Operand)visitExpression(ctx.expression());
        if (operand == null) {
            return null;
        }
        Predicate condition = null;
        if (ctx.multiple_condition() != null) {
            condition = (Predicate)visitMultiple_condition(ctx.multiple_condition());
        }
        queryManager.update(table_name, column_name, operand, condition);
        return null;
    }

    @Override
    public Object visitColumn_def(SQLParser.Column_defContext ctx) {
        // construct a column step by step
        Column column = (Column)visitType_name(ctx.type_name());
        String name = ctx.column_name().getText();
        column.setName(name);
        for (SQLParser.Column_constraintContext constraint : ctx.column_constraint()) {
            if (constraint.K_PRIMARY() != null) {
                logBuffer.write("NotImplementError: primary key can only be set at the end of statement.");
                hasSyntaxError = true;
                return null;
            }
            if (constraint.K_NOT() != null) {
                column.setNotNull(true);
            }
        }
        return column;
    }

    @Override
    public Object visitType_name(SQLParser.Type_nameContext ctx) {
        if (ctx.T_INT() != null) {
            return new Column(null, ColumnType.INT, false, false, 0);
        }
        else if (ctx.T_LONG() != null) {
            return new Column(null, ColumnType.LONG, false, false, 0);
        }
        else if (ctx.T_FLOAT() != null) {
            return new Column(null, ColumnType.FLOAT, false, false, 0);
        }
        else if (ctx.T_DOUBLE() != null) {
            return new Column(null, ColumnType.DOUBLE, false, false, 0);
        }
        else {
            int length = Integer.parseInt(ctx.NUMERIC_LITERAL().getText());
            return new Column(null, ColumnType.STRING, false, false, length);
        }
    }

    @Override
    public Object visitMultiple_condition(SQLParser.Multiple_conditionContext ctx) {
        if (ctx.AND() == null && ctx.OR() == null) {
            return (Predicate)visitCondition(ctx.condition());
        }
        else {
            Predicate lhs = (Predicate)visitMultiple_condition(ctx.multiple_condition(0));
            Predicate rhs = (Predicate)visitMultiple_condition(ctx.multiple_condition(1));
            if (ctx.AND() != null) {
                return new AndPredicate(lhs, rhs);
            }
            else {
                return new OrPredicate(lhs, rhs);
            }
        }
    }

    @Override
    public Object visitColumn_constraint(SQLParser.Column_constraintContext ctx) {
        // use default
        return super.visitColumn_constraint(ctx);
    }

    @Override
    public Object visitComparer(SQLParser.ComparerContext ctx) {
        Operand operand = null;
        // full name or constant
        if (ctx.column_full_name() != null) {
            operand = new Operand(false);
            Column column = (Column)visitColumn_full_name(ctx.column_full_name());
            if (column.getTable_name() != null) {
                operand.setName(column.getTable_name() + "." + column.getName());
            }
            else {
                operand.setName(column.getName());
            }
        }
        else {
            operand = (Operand)visitLiteral_value(ctx.literal_value());
        }
        return operand;
    }

    @Override
    public Object visitComparator(SQLParser.ComparatorContext ctx) {
        if (ctx.EQ() != null) {
            return EqualPredicate.class;
        }
        else if (ctx.NE() != null) {
            return NotEqualPredicate.class;
        }
        else if (ctx.LE() != null) {
            return LessEqualPredicate.class;
        }
        else if (ctx.GE() != null) {
            return GreaterEqualPredicate.class;
        }
        else if (ctx.LT() != null) {
            return LessThanPredicate.class;
        }
        else {
            return GreaterThanPredicate.class;
        }
    }

    @Override
    public Object visitExpression(SQLParser.ExpressionContext ctx) {
        if (ctx.ADD() != null || ctx.SUB() != null || ctx.DIV() != null || ctx.MUL() != null || ctx.comparer() == null) {
            logBuffer.write("NotImplementError: arithmetic expression not implemented.(for now)");
            hasSyntaxError = true;
            return null;
        }
        return (Operand)visitComparer(ctx.comparer());
    }

    @Override
    public Object visitResult_column(SQLParser.Result_columnContext ctx) {
        if (ctx.MUL() != null || ctx.table_name() != null) {
            logBuffer.write("NotImplementError: * and table_name.* not implemented.");
            hasSyntaxError = true;
            return null;
        }
        return (Column)visitColumn_full_name(ctx.column_full_name());
    }

    @Override
    public Object visitTable_query(SQLParser.Table_queryContext ctx) {
        VirtualTable vt = new VirtualTable();
        if (ctx.K_JOIN().size() != 0) {
            // join
            for (SQLParser.Table_nameContext tablename : ctx.table_name()) {
                vt.tables.add(tablename.getText());
            }
            vt.condition = (Predicate)visitMultiple_condition(ctx.multiple_condition());
        }
        else {
            vt.tables.add(ctx.table_name(0).getText());
        }
        return vt;
    }

    // return a string if not null
    @Override
    public Object visitLiteral_value(SQLParser.Literal_valueContext ctx) {
        Operand operand = new Operand(true);
        if (ctx.NUMERIC_LITERAL() != null) {
            operand.setValue(new Entry(ctx.NUMERIC_LITERAL().getText()));
        }
        else if (ctx.STRING_LITERAL() != null) {
            operand.setValue(new Entry(ctx.STRING_LITERAL().getText()));
        }
        else {
            operand.setValue(new Entry(null));
        }
        return operand;
    }

    @Override
    public Object visitColumn_full_name(SQLParser.Column_full_nameContext ctx) {
        String column_name = ctx.column_name().getText();
        Column column = new Column(column_name, null, false, false, 0);
        if (ctx.table_name() != null) {
            column.setTable_name(ctx.table_name().getText());
        }
        return column;
    }

    @Override
    public Object visitTable_name(SQLParser.Table_nameContext ctx) {
        // use default
        return super.visitTable_name(ctx);
    }

    @Override
    public Object visitColumn_name(SQLParser.Column_nameContext ctx) {
        // default
        return super.visitColumn_name(ctx);
    }

    @Override
    public Object visitCondition(SQLParser.ConditionContext ctx) {
        Operand lhs = (Operand) visitExpression(ctx.expression(0));
        Operand rhs = (Operand) visitExpression(ctx.expression(1));

        if (lhs == null || rhs == null) {
            return null;
        }

        Class c = (Class)visitComparator(ctx.comparator());
        Predicate result;
        // instantiate the predicate
        try {
            result = (Predicate)c.getConstructor(Operand.class, Operand.class).newInstance(lhs, rhs);
        }
        catch (Exception e) {
            result = null;
        }
        return result;
    }

    @Override
    public Object visitShow_table_stmt(SQLParser.Show_table_stmtContext ctx) {
        logBuffer.write("NotImplementError: show database not implemented.");
        hasSyntaxError = true;
        return null;
    }

    @Override
    public Object visitCreate_db_stmt(SQLParser.Create_db_stmtContext ctx) {
        logBuffer.write("NotImplementError: create database not implemented.");
        hasSyntaxError = true;
        return null;
    }

    @Override
    public Object visitDrop_db_stmt(SQLParser.Drop_db_stmtContext ctx) {
        logBuffer.write("NotImplementError: drop database not implemented.");
        hasSyntaxError = true;
        return null;
    }

    @Override
    public Object visitCreate_user_stmt(SQLParser.Create_user_stmtContext ctx) {
        logBuffer.write("NotImplementError: create user not implemented.");
        hasSyntaxError = true;
        return null;
    }

    @Override
    public Object visitDrop_user_stmt(SQLParser.Drop_user_stmtContext ctx) {
        logBuffer.write("NotImplementError: drop user not implemented.");
        hasSyntaxError = true;
        return null;
    }

    @Override
    public Object visitGrant_stmt(SQLParser.Grant_stmtContext ctx) {
        logBuffer.write("NotImplementError: grant not implemented.");
        hasSyntaxError = true;
        return null;
    }

    @Override
    public Object visitRevoke_stmt(SQLParser.Revoke_stmtContext ctx) {
        logBuffer.write("NotImplementError: revoke not implemented.");
        hasSyntaxError = true;
        return null;
    }

    @Override
    public Object visitUse_db_stmt(SQLParser.Use_db_stmtContext ctx) {
        logBuffer.write("NotImplementError: use database not implemented.");
        hasSyntaxError = true;
        return null;
    }

    @Override
    public Object visitShow_db_stmt(SQLParser.Show_db_stmtContext ctx) {
        logBuffer.write("NotImplementError: show database not implemented.");
        hasSyntaxError = true;
        return null;
    }

    @Override
    public Object visitCreate_view_stmt(SQLParser.Create_view_stmtContext ctx) {
        logBuffer.write("NotImplementError: create view not implemented.");
        hasSyntaxError = true;
        return null;
    }

    @Override
    public Object visitDrop_view_stmt(SQLParser.Drop_view_stmtContext ctx) {
        logBuffer.write("NotImplementError: drop view not implemented.");
        hasSyntaxError = true;
        return null;
    }

    @Override
    public Object visitTable_constraint(SQLParser.Table_constraintContext ctx) {
        logBuffer.write("NotImplementError: multiple primary key not implemented.");
        hasSyntaxError = true;
        return null;
    }

    @Override
    public Object visitAuth_level(SQLParser.Auth_levelContext ctx) {
        logBuffer.write("NotImplementError: auth level not implemented.");
        hasSyntaxError = true;
        return null;
    }

    @Override
    public Object visitDatabase_name(SQLParser.Database_nameContext ctx) {
        logBuffer.write("NotImplementError: database name not implemented.");
        hasSyntaxError = true;
        return null;
    }

    @Override
    public Object visitUser_name(SQLParser.User_nameContext ctx) {
        logBuffer.write("NotImplementError: user name not implemented.");
        hasSyntaxError = true;
        return null;
    }

    @Override
    public Object visitView_name(SQLParser.View_nameContext ctx) {
        logBuffer.write("NotImplementError: view name not implemented.");
        hasSyntaxError = true;
        return null;
    }

    @Override
    public Object visitPassword(SQLParser.PasswordContext ctx) {
        logBuffer.write("NotImplementError: password not implemented.");
        hasSyntaxError = true;
        return null;
    }
}
